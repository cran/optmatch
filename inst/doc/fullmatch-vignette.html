<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>The <em>R</em> Environment</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>The <em>R</em> Environment</h1>

<p>All the software used in this worksheet is freely available. The <em>R</em>
statistical package is installed for you in the lab, but you may
download and install <em>R</em> for Windows, Mac, and Linux systems from:
<a href="https://www.r-project.org">https://www.r-project.org</a>.</p>

<p>The following document walks through a common propensity score
matching work-flow in <em>R</em>. Example <em>R</em> code will appear with a <code>&gt;</code>
indicating the command prompt. You may type this code yourself &mdash;
each line is a command to <em>R</em>. Output will follow prefaced by
<code>##</code>. (In <em>R</em>, <code>#</code> represents a comment; any command preceded by any
number of <code>#</code>&#39;s will not be executed.) For example:</p>

<pre><code class="r">&gt; 2 + 2
## [1] 4
</code></pre>

<p>(Note that when entering the code yourself, do not include the <code>&gt;</code> in
your command. Also, for longer lines of code in this document, the
text may wrap onto a second line, with the second line preceded by a
<code>+</code> sign. When entering the code yourself, you do not have to wrap the
lines, and do not include the <code>+</code>.)</p>

<p><em>R</em> stores data in named variables using the arrow operator:</p>

<pre><code class="r">&gt; my.variable &lt;- 2 + 2
&gt; my.variable * 3
## [1] 12
</code></pre>

<h1>Setup</h1>

<h2>Outfitting your <em>R</em> with the proper add-ons</h2>

<p><em>R</em> add-on packages are available to install directly from <em>R</em>:</p>

<pre><code class="r">&gt; install.packages(&quot;optmatch&quot;)
&gt; install.packages(&quot;RItools&quot;)
</code></pre>

<p>These commands will ask you to select a CRAN server. Any server will
do.  You may also be asked whether you&#39;d like to set up a &ldquo;personal
library to install packages into&rdquo;; if so, answer yes.  (The default
personal library location that <em>R</em> will suggest should be OK.) You&#39;ll
only need to run these commands the first time you want to use
<code>optmatch</code> or <code>RItools</code> on a particular computer, or when you install
a new version of <em>R</em>.</p>

<h2>Setting up the <em>R</em> environment for matching</h2>

<p>Attach extension packages that we&#39;ll be using for matching and
associated diagnostics:</p>

<pre><code class="r">&gt; library(optmatch)
&gt; library(RItools)
</code></pre>

<p>You&#39;ll do this each time you start a new <em>R</em> session and want to run
matching commands.</p>

<p>To load the nuclear plants data, enter</p>

<pre><code class="r">&gt; data(nuclearplants)
</code></pre>

<p>To see the first six rows:</p>

<pre><code class="r">&gt; head(nuclearplants)
##     cost  date t1 t2  cap pr ne ct bw cum.n pt
## H 460.05 68.58 14 46  687  0  1  0  0    14  0
## I 452.99 67.33 10 73 1065  0  0  1  0     1  0
## A 443.22 67.33 10 85 1065  1  0  1  0     1  0
## J 652.32 68.00 11 67 1065  0  1  1  0    12  0
## B 642.23 68.00 11 78 1065  1  1  1  0    12  0
## K 345.39 67.92 13 51  514  0  1  1  0     3  0
</code></pre>

<p>For more on the variables here, enter</p>

<pre><code class="r">&gt; help(&quot;nuclearplants&quot;)
</code></pre>

<p>You can directly access a variable within this data frame as follows.
(Try typing in the commands to see what they do.)</p>

<pre><code class="r">&gt; nuclearplants$pt
&gt; table(nuclearplants$pt)
&gt; with(nuclearplants, table(pt))
</code></pre>

<p>The variable you will have just viewed and tabulated, <code>pt</code>, is a dummy
for whether the plant was built with &ldquo;partial turnkey guarantees.&rdquo;
These plants were not comparable to the others in terms of
construction costs.  Let&#39;s exclude them for the time being, for
simplicity.  To do this we&#39;ll create a data table (in <em>R</em> jargon, a
&ldquo;data frame&rdquo;) of just those observations for which <code>pt</code> is 0:</p>

<pre><code class="r">&gt; nuke.nopt &lt;- subset(nuclearplants, pt == 0)
</code></pre>

<p>To inspect its first six or last six entries, do</p>

<pre><code class="r">&gt; head(nuke.nopt)
&gt; tail(nuke.nopt)
</code></pre>

<p>To view this as presenting a matching problem, we&#39;ll think of plants
built on the site of a previously existing plant (<code>pr == 1</code>) as the
treatment group and plants on new sites (<code>pr == 0</code>) as comparisons.</p>

<h1>Optimal pair matching and 1:k matching</h1>

<h2>Pair matching</h2>

<p>To check the number of treated and control plants:</p>

<pre><code class="r">&gt; table(nuke.nopt$pr)
## 
##  0  1 
## 19  7
</code></pre>

<p>To get the pair match minimizing the mean paired distance on <code>cap</code>,
among all collections of 7 non-overlapping pairs, do</p>

<pre><code class="r">&gt; pairmatch(pr ~ cap, data = nuke.nopt)
##    H    I    A    J    B    K    L    M    C    N    O    P    Q    R    S 
## &lt;NA&gt;  1.2  1.1  1.1  1.2 &lt;NA&gt;  1.3 &lt;NA&gt;  1.3  1.7 &lt;NA&gt; &lt;NA&gt;  1.4  1.5 &lt;NA&gt; 
##    T    U    D    V    E    W    F    X    G    Y    Z 
## &lt;NA&gt;  1.6  1.4 &lt;NA&gt;  1.5 &lt;NA&gt;  1.6 &lt;NA&gt;  1.7 &lt;NA&gt; &lt;NA&gt;
</code></pre>

<p>For a more readable report of who gets matched to whom, type</p>

<pre><code class="r">&gt; print(pairmatch(pr ~ cap, data = nuke.nopt), grouped = TRUE)
##  Group Members
##    1.1    A, J
##    1.2    I, B
##    1.3    L, C
##    1.4    Q, D
##    1.5    R, E
##    1.6    U, F
##    1.7    N, G
</code></pre>

<p>For matching on both <code>date</code> and <code>cap</code>, you&#39;d type pairmatch(pr ~ cap</p>

<ul>
<li>date, &hellip;)<code>instead of</code>pairmatch(pr ~ cap, &hellip;)<code>. We&#39;ll talk later
about how this combines discrepancies on the two variables.  For now,
note the form of the output this command generates: a variable of the
same length as the variables making up</code>nuke.nopt<code>, assigning a
distinct name to each matched set.  To fix your intuition, you might
try connecting up below the units that</code>pairmatch() has placed in the
same matched sets.</li>
</ul>

<hr/>

<p>Plant   Date   Capacity   Plant   Date   Capacity </p>

<hr/>

<p>A     2.3      660        H     3.6      290    </p>

<p>B     3.0      660        I     2.3      660    </p>

<p>C     3.4      420        J      3       660    </p>

<p>D     3.4      130        K     2.9      110    </p>

<p>E     3.9      650        L     3.2      420    </p>

<p>F     5.9      430        M     3.4       60    </p>

<p>G     5.1      420        N     3.3      390    </p>

<pre><code>                         O     3.6      160    

                         P     3.8      390    

                         Q     3.4      130    

                         R     3.9      650    

                         S     3.9      450    

                         T     3.4      380    

                         U     4.5      440    

                         V     4.2      690    

                         W     3.8      510    

                         X     4.7      390    

                         Y     5.4      140    

                         Z     6.1      730    
</code></pre>

<hr/>

<p>Table: New-site (left columns) versus existing-site (right columns) plants. &ldquo;date&rdquo; is <code>date-65</code>; &ldquo;capacity&rdquo; is <code>cap-400</code>.</p>

<p>For basic summary information about this match, try</p>

<pre><code class="r">&gt; summary(pairmatch(pr ~ cap, data = nuke.nopt))
</code></pre>

<p>If you&#39;ve already typed in the <code>pairmatch(...)</code> part, you can use the
up-arrow, Home and End keys to avoid having to re-type. Alternatively,
to assign the name &ldquo;<code>pm</code>&rdquo; to the matching result, do</p>

<pre><code class="r">&gt; pm &lt;- pairmatch(pr ~ cap, data = nuke.nopt)
</code></pre>

<p>Now, you can just type <code>print(pm, grouped = TRUE)</code> or <code>summary(pm)</code>.</p>

<p>The following would give a basic matched analysis of the effect of new
or existing site on construction costs is given with the help of <em>R</em>&#39;s
linear modeling function.  In effect, the existing site effect is
estimated as one &ldquo;way&rdquo; in a two-way \textsc{anova}, the other &ldquo;way&rdquo;
being the factor variable that represents the matching result,
i.e. <code>pm</code>.</p>

<pre><code class="r">&gt; summary(lm(cost ~ pr + pm, data = nuke.nopt))
</code></pre>

<h2>Matching with multiple controls</h2>

<p>There are other types of matches you might want to try.  Here&#39;s how to
create matched triples (each treatment group unit is matched to two
control group units):</p>

<pre><code class="r">&gt; tm &lt;- pairmatch(pr ~ cap, controls = 2, data = nuke.nopt)
</code></pre>

<p>There will be further variations suggested on the slides.</p>

<h2>Did matching work?</h2>

<p>It&#39;s possible to give the software an impossible list of requirements
for a match.  For instance, try running the following:</p>

<pre><code class="r">&gt; pairmatch(pr ~ cap, controls = 3, data=nuke.nopt)
</code></pre>

<p>The problem here is that the data don&#39;t have 3 comparison units to go
with each treatment unit, since we have 7 treatment units but only 19
comparison units.</p>

<p>Matching can also fail because the distance matrix embodies matching
constraints that are impossible to meet.  In these cases the matching
function will generally run without complaint, although it won&#39;t
create any matches.  Here is an example, where the caliper is so
narrow as to forbid all possible matches:</p>

<pre><code class="r">&gt; pairmatch(pr ~ cap + cost, caliper=.001, data = nuke.nopt)
##    H    I    A    J    B    K    L    M    C    N    O    P    Q    R    S 
## &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 
##    T    U    D    V    E    W    F    X    G    Y    Z 
## &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;
</code></pre>

<p>Behind the scenes, the <code>caliper</code> argument restricts how the maximum
distance between matched objects. For example, consider Table 1
above. Plants A and H are 1.3 units apart in <code>date</code>. If we assigned
<code>caliper=1</code>, they could never be matched because they exceed the
caliper limit.</p>

<p>If before matching you want to remove just the subjects lacking a
counterpart within caliper distance, you can do <code>pairmatch(...,
remove.unmatchables = TRUE)</code>.  That won&#39;t help with the minuscule
caliper above, but with less extreme calipers it helps you salvage a
few matches.</p>

<h2>How closely did I match?</h2>

<p>Getting back to a matching that succeeded, note that <code>summary()</code>
reports information about how close the matches are.</p>

<pre><code class="r">&gt; summary(pm)
## Structure of matched sets:
## 1:1 0:1 
##   7  12 
## Effective Sample Size:  7 
## (equivalent number of matched pairs).
</code></pre>

<h2>Did matching balance the covariate?</h2>

<p>Comparing overt biases before and after matching.  An assessment of
the unmatched difference between the groups on <code>cap</code> can be had via:</p>

<pre><code class="r">&gt; cap.noadj &lt;- lm(cap ~ pr, data = nuke.nopt)
&gt; summary(cap.noadj)
</code></pre>

<p>The output is suppressed, as most of it is not relevant to balance.
This variation hones in on the part that is:</p>

<pre><code class="r">&gt; summary(lm(cap ~ pr, data = nuke.nopt))$coeff[&quot;pr&quot;,]
##   Estimate Std. Error    t value   Pr(&gt;|t|) 
## 79.7368421 92.7031668  0.8601307  0.3982280
</code></pre>

<p>(Note again the use of square brackets, <code>[</code> and <code>]</code>, for specifying
subsets of a matrix.  With <em>R</em> one has to carefully distinguish square
brackets, curly brackets and parentheses.)</p>

<p>Here is a parallel calculation that takes the match <code>pm</code> into account.</p>

<pre><code class="r">&gt; summary(lm(cap ~ pr + pm, data = nuke.nopt))$coeff[&quot;pr&quot;,]
##   Estimate Std. Error    t value   Pr(&gt;|t|) 
##  1.7142857  5.1395492  0.3335479  0.7500689
</code></pre>

<p>The RItools package&#39;s <code>xBalance</code> function zeroes in on balance, and
facilitates checking balance on multiple variables at the same time. Here are some examples:</p>

<pre><code class="r">&gt; 
&gt; xBalance(pr ~ cap + t2, report=&quot;all&quot;, data=nuke.nopt)
##      strata unstrat                                                           
##      stat      pr=0    pr=1 adj.diff adj.diff.null.sd std.diff    z           
## vars                                                                          
## cap         803.263 883.000  79.737           92.220   0.380   0.865          
## t2          59.526  66.857   7.331            4.547    0.738   1.612          
## ---Overall Test---
##         chisquare df p.value
## unstrat      2.71  2   0.258
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;** &#39; 0.01 &#39;*  &#39; 0.05 &#39;.  &#39; 0.1 &#39;   &#39; 1
&gt; xBalance(pr ~ cap + t2 + strata(pm),
+          data=nuke.nopt,
+          report=c(&quot;adj.mean.diffs&quot;, &quot;std&quot;, &quot;z&quot;))
##      strata    Unadj                                  pm                           
##      stat   adj.diff std.diff     z             adj.diff std.diff     z            
## vars                                                                               
## cap         79.73684 0.38030  0.86464           1.71429  0.00818  0.35698          
## t2          7.33083  0.73777  1.61209           4.71429  0.47444  1.16892
</code></pre>

<p><strong>Exercises.</strong></p>

<ol>
<li>Compare <code>pm</code>, <code>tm</code> and the unmatched samples in terms of balance on
<code>t2</code>.</li>
<li>Compare <code>pm</code>, <code>tm</code> and the unmatched samples in terms of balance on
<code>date</code>.</li>
<li>Compare <code>pm</code> to Mahalanobis pair matching on <code>t1</code> in terms of
balance on <code>date</code>.</li>
<li>Compare Mahalanobis pair matching on <code>cap</code> and <code>date</code> to
Mahalanobis pair matching on <code>cap</code>, <code>date</code> and each of <code>t1,t2</code>.  Add
the last two variables in one at a time, so that you&#39;re comparing a
total of three matches.  Compare on balance in <code>cap</code> and <code>t2</code>.</li>
</ol>

<p>Section &ldquo;Checking balance in general&rdquo;, below, presents convenient ways
to do balance assessment for many variables at once.  Before getting
to that let&#39;s discuss try matching with propensity scores.</p>

<h1>Propensity Score Matching</h1>

<h2>Propensity score fitting in <em>R</em></h2>

<p>Logistic regression models are fit in <em>R</em> using the function <code>glm()</code>,
with &ldquo;<code>family</code>&rdquo; argument set to &ldquo;<code>binomial</code>.&rdquo;  Example:</p>

<pre><code class="r">&gt; psm &lt;- glm(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n + pt,
+            family = binomial, data = nuclearplants)
</code></pre>

<p>The fitted logistic regression is then stored in the object &ldquo;<code>psm</code>.&rdquo;
The propensity scores can be accessed with <code>psm$fitted.values</code>
(estimated probabilities) or <code>scores(psm)</code> (estimated logits of
probabilities).</p>

<p>It&#39;s often a good idea to compare the groups&#39; distributions on the
propensity score.</p>

<pre><code class="r">&gt; boxplot(psm)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-30"/></p>

<p>The groups do overlap, if not greatly.  It may be wise to restrict the
sample to the region of overlap, at least roughly.  A propensity
caliper would help with this.</p>

<p>First, lets match directly on the propensity score without restricting
the sample to the region of overlap.</p>

<pre><code class="r">&gt; ps.pm &lt;- pairmatch(psm, data = nuclearplants)
&gt; summary(ps.pm)
## Structure of matched sets:
## 1:1 0:1 
##  10  12 
## Effective Sample Size:  10 
## (equivalent number of matched pairs).
</code></pre>

<p>To restrict to the overlapping region, we want to imply a caliper to
the distances generated by the propensity score model. To do this
requires a more explicit generation of the match, involving separate
steps for generation of the distances followed by matching upon those
distances.</p>

<p>First, we create a distance matrix based upon <code>psm</code>:</p>

<pre><code class="r">&gt; psm.dist &lt;- match_on(psm, data=nuclearplants)
</code></pre>

<p><code>psm.dist</code> is a matrix with an entry corresponding to the distance
between each potential pair of treatment and control units. We can
caliper directly on this distance matrix,</p>

<pre><code class="r">&gt; caliper(psm.dist, 2)
##        control
## treated   H   I   J   K   L   M   N   O   P   Q   R   S   T U   V   W   X
##       A Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf 0   0 Inf Inf
##       B Inf   0 Inf Inf Inf   0   0   0 Inf   0   0   0   0 0   0   0 Inf
##       C Inf   0   0 Inf Inf   0   0   0 Inf   0   0   0   0 0 Inf   0   0
##       D Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf   0 Inf 0   0 Inf Inf
##       E Inf   0 Inf Inf Inf   0   0   0 Inf   0   0   0   0 0   0   0   0
##       F Inf   0 Inf Inf Inf   0 Inf   0 Inf Inf   0   0   0 0   0 Inf Inf
##       G Inf   0 Inf Inf Inf   0   0   0 Inf   0   0   0   0 0   0   0 Inf
##       a Inf   0 Inf Inf Inf Inf Inf Inf Inf Inf   0   0   0 0   0 Inf Inf
##       b Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf 0   0 Inf Inf
##       c Inf   0 Inf Inf Inf   0   0   0 Inf   0   0   0   0 0   0   0 Inf
##        control
## treated   Y   Z d   e   f
##       A Inf Inf 0 Inf Inf
##       B Inf   0 0 Inf   0
##       C Inf   0 0 Inf   0
##       D Inf Inf 0 Inf Inf
##       E Inf   0 0 Inf   0
##       F Inf   0 0 Inf   0
##       G Inf   0 0 Inf   0
##       a Inf   0 0 Inf   0
##       b Inf Inf 0 Inf Inf
##       c Inf   0 0 Inf   0
</code></pre>

<p>Entries which are <code>Inf</code> will never be matched. Adding the caliper to
<code>psm.dist</code> will disallow matching between units which differ by more
than 2 standard deviations.</p>

<p>(Note that this differs from the previous use of <code>caliper</code> directly in
<code>pairmatch</code>, where the caliper is applied directly to the distances
instead of smartly upon the standard deviations between the propensity
scores.)</p>

<p>Combining the above, we can now</p>

<pre><code class="r">&gt; ps.pm2 &lt;- pairmatch(psm.dist, data = nuclearplants)
&gt; ps.pm3 &lt;- pairmatch(psm.dist + caliper(psm.dist, 2), data = nuclearplants)
&gt; all.equal(ps.pm, ps.pm2, check.attributes=FALSE)
## [1] TRUE
&gt; all.equal(ps.pm, ps.pm3, check.attributes=FALSE)
## [1] &quot;8 string mismatches&quot;
&gt; summary(ps.pm3)
## Structure of matched sets:
## 1:1 0:1 
##  10  12 
## Effective Sample Size:  10 
## (equivalent number of matched pairs).
</code></pre>

<p>Or you could match within calipers of the propensity score on some
other distance, perhaps Mahalanobis distances based on selected
covariates as recommended by Rubin and Thomas (2000, JASA) and
others. For Mahalanobis matching on <code>date</code>, <code>cap</code> and the propensity
score, for instance, combined with a propensity caliper of 1 pooled
sd.</p>

<pre><code class="r">&gt; mhd1 &lt;- match_on(pr ~ date + cap + scores(psm), data=nuclearplants)
&gt; mhpc.pm &lt;- pairmatch(mhd1, caliper=1, data=nuclearplants)
&gt; summary(mhpc.pm) # oops
## Structure of matched sets:
## 1:1 0:1 
##  10  12 
## Effective Sample Size:  10 
## (equivalent number of matched pairs).
&gt; mhpc.pm &lt;- pairmatch(mhd1, caliper=2, data=nuclearplants)
&gt; summary(mhpc.pm) # better!
## Structure of matched sets:
## 1:1 0:1 
##  10  12 
## Effective Sample Size:  10 
## (equivalent number of matched pairs).
</code></pre>

<h2>Checking balance in general</h2>

<p>The <code>RItools</code> package has a convenient function for checking balance
on many variables simultaneously.  To get a sense of what it does, try
this:</p>

<pre><code class="r">&gt; library(RItools)
&gt; xBalance(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n, data = nuclearplants)
&gt; xBalance(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n + pt +
+              strata(ps.pm2) -1, # the `-1` just focuses the output a little
+          data = nuclearplants)
</code></pre>

<p>It can in the same display compare matching to no matching, on any of
a number of axes.  Here is a demonstration:</p>

<pre><code class="r">&gt; myb &lt;- xBalance(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n +
+                 strata(ps.pm2),
+                 data = nuclearplants,
+                 report = c(&quot;adj.means&quot;, &quot;std.diffs&quot;,
+                            &quot;z.scores&quot;, &quot;chisquare.test&quot;))
&gt; plot(myb)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-37"/></p>

<pre><code class="r">&gt; print(myb, digits=1)
##       strata  Unadj                                ps.pm2                               
##       stat     pr=0   pr=1 std.diff    z             pr=0   pr=1 std.diff    z          
## vars                                                                                    
## date         68.62  68.50    -0.11   -0.31         68.68  68.50    -0.18   -0.36        
## t1           13.64  14.00    0.11    0.28          14.30  14.00    -0.09   -0.17        
## t2           59.32  69.10    1.03    2.47   *      62.60  69.10    0.69    1.43         
## cap          805.18 869.80   0.34    0.89          889.60 869.80   -0.10   -0.29        
## ne           0.27   0.20     -0.16   -0.43         0.10   0.20     0.22    0.58         
## ct           0.45   0.30     -0.31   -0.81         0.20   0.30     0.20    0.45         
## bw           0.18   0.20     0.05    0.12          0.20   0.20     0.00    0.00         
## cum.n        8.73   8.10     -0.10   -0.26         8.60   8.10     -0.08   -0.19        
## ---Overall Test---
##        chisquare df p.value
## Unadj         11  8     0.2
## ps.pm2         9  8     0.4
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;** &#39; 0.01 &#39;*  &#39; 0.05 &#39;.  &#39; 0.1 &#39;   &#39; 1
</code></pre>

<p>For a very compact representation of the assessment, call <code>summary()</code>
on the match, passing along the fitted propensity model as a second
argument.  If you&#39;ve got <code>RItools</code> loaded, then this will call
<code>xBalance</code> in the background, reporting the summary chi-square test
results.</p>

<pre><code class="r">&gt; summary(ps.pm2, psm)
## Structure of matched sets:
## 1:1 0:1 
##  10  12 
## Effective Sample Size:  10 
## (equivalent number of matched pairs).
## 
## Balance test overall result:
##   chisquare df p.value
##          10  9   0.351
</code></pre>

<p><strong>Exercise.</strong></p>

<p>Try out {at least 3} different combinations of propensity score and
Mahalanobis matching.  Identify the matches that gives:</p>

<ol>
<li>the &ldquo;best balance overall,&rdquo; as measured by Chi-square statistics;</li>
<li>the &ldquo;best balance overall,&rdquo; as indicated by the largest
standardized difference among the covariates;</li>
<li>the best balance on <code>date</code> and <code>cap</code>, as measured by the larger of
the standardized differences for these two variables; and</li>
<li>the best balance on <code>date</code> and <code>cap</code>, as measured by the larger of
the standardized differences for these two variables, among those
matches for which the overall imbalance <em>p</em>-value is no more than
.1.</li>
</ol>

<h1>Other topics in matching</h1>

<h2>Full matching and matching with a varying number of controls</h2>

<p>Try out for yourself and compare:</p>

<pre><code class="r">&gt; summary(fullmatch(pr ~ date + cap, data = nuke.nopt))
&gt; summary(fullmatch(pr ~ date + cap, data = nuke.nopt, min = 1))
&gt; summary(fullmatch(pr ~ date + cap, data = nuke.nopt, min = 2, max = 3))
</code></pre>

<h2>Subclassification before matching</h2>

<p>Recall that the data set <code>nuclearplants</code> had 32 observations, 6 of
which we excluded.  These were plants built under &ldquo;partial turnkey&rdquo;
guarantees (<code>pt == 1</code>), for which costs are difficult to compare with
other plants.  We might include the excluded plants by matching them
only among themselves.  Then we need to subclassify prior to matching.</p>

<p>This is a common and useful operation, and <code>optmatch</code> is designed to
help you do it via a <code>strata</code> term in the matching formula.</p>

<pre><code class="r">&gt; pairmatch(pr ~ date + cap + scores(psm), data=nuclearplants)
##    H    I    A    J    B    K    L    M    C    N    O    P    Q    R    S 
## &lt;NA&gt;  1.1  1.1 &lt;NA&gt;  1.2 &lt;NA&gt; &lt;NA&gt;  1.4  1.3  1.3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;  1.2 &lt;NA&gt; 
##    T    U    D    V    E    W    F    X    G    Y    Z    d    e    f    a 
##  1.8  1.7  1.4  1.5  1.5 &lt;NA&gt;  1.6  1.6  1.7 &lt;NA&gt; &lt;NA&gt;  1.9 &lt;NA&gt; 1.10  1.8 
##    b    c 
##  1.9 1.10
&gt; pairmatch(pr ~ date + cap + scores(psm) + strata(pt), data=nuclearplants)
##    H    I    A    J    B    K    L    M    C    N    O    P    Q    R    S 
## &lt;NA&gt;  0.1  0.1 &lt;NA&gt;  0.2 &lt;NA&gt; &lt;NA&gt;  0.4  0.3  0.3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt;  0.2 &lt;NA&gt; 
##    T    U    D    V    E    W    F    X    G    Y    Z    d    e    f    a 
## &lt;NA&gt;  0.7  0.4  0.5  0.5 &lt;NA&gt;  0.6  0.6  0.7 &lt;NA&gt; &lt;NA&gt;  1.2  1.1  1.3  1.1 
##    b    c 
##  1.2  1.3
</code></pre>

<h2>Distances</h2>

<p>You&#39;ll often want to do several variations on a match.  It may save
computation and typing time to store the distance you&#39;re using to
match, if you&#39;re going to re-use that distance.  To do so, you&#39;ll have
to explicitly separate distance-making and matching, two steps that
we&#39;ve merged together thus far. We&#39;ll use the <code>match_on()</code> to
create distances.</p>

<pre><code class="r">&gt; cap.dist &lt;- match_on(pr ~ cap, data = nuke.nopt)
&gt; pm1 &lt;- pairmatch(pr ~ cap, data=nuke.nopt)
&gt; pm2 &lt;- pairmatch(cap.dist, data=nuke.nopt)
&gt; all.equal(pm1, pm2, check.attributes = FALSE)
## [1] TRUE
&gt; summary(pm2)
## Structure of matched sets:
## 1:1 0:1 
##   7  12 
## Effective Sample Size:  7 
## (equivalent number of matched pairs).
</code></pre>

<p>What does a matching distance look like?  Here&#39;s the upper-left corner
of one of them:</p>

<pre><code class="r">&gt; round(cap.dist[1:3, 1:3], 1)
##          control
## treatment   H   I   J
##         A 1.8 0.0 0.0
##         B 1.8 0.0 0.0
##         C 0.6 1.2 1.2
</code></pre>

<p>(Note the use of square brackets, <code>[</code> and <code>]</code>, for specifying rows and
columns of the distance matrix.  If you find that this isn&#39;t working
on a distance that you&#39;ve produced, try <code>as.matrix(my.dist)[1:3,1:3]</code>
or similar.)</p>

<p>Matching with a caliper of 2 pooled standard deviations on the <code>cap</code>
variable:</p>

<pre><code class="r">&gt; round(cap.dist + caliper(cap.dist, 2), 1)
##        control
## treated   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W
##       A 1.8 0.0 0.0 Inf 1.2 Inf 1.3 Inf 1.3 Inf 0.1 1.0 1.4 1.0 0.1 0.7
##       B 1.8 0.0 0.0 Inf 1.2 Inf 1.3 Inf 1.3 Inf 0.1 1.0 1.4 1.0 0.1 0.7
##       C 0.6 1.2 1.2 1.5 0.0 1.7 0.1 1.2 0.2 1.4 1.1 0.1 0.2 0.1 1.3 0.4
##       D 0.7 Inf Inf 0.1 1.4 0.3 1.2 0.1 1.2 0.0 Inf 1.5 1.2 1.5 Inf 1.8
##       E 1.7 0.1 0.1 Inf 1.1 Inf 1.2 Inf 1.2 Inf 0.0 1.0 1.3 1.0 0.2 0.7
##       F 0.7 1.1 1.1 1.5 0.0 1.8 0.2 1.3 0.2 1.4 1.1 0.1 0.2 0.1 1.2 0.4
##       G 0.6 1.2 1.2 1.5 0.0 1.7 0.1 1.2 0.1 1.4 1.1 0.1 0.2 0.1 1.3 0.4
##        control
## treated   X   Y   Z
##       A 1.3 Inf 0.3
##       B 1.3 Inf 0.3
##       C 0.2 1.4 1.5
##       D 1.2 0.0 Inf
##       E 1.3 Inf 0.4
##       F 0.2 1.4 1.4
##       G 0.2 1.3 1.5
</code></pre>

<p>Entries of <code>Inf</code> or <code>NaN</code> in a distance matrix are interpreted as
forbidden matches.  Thus</p>

<pre><code class="r">&gt; pairmatch(cap.dist + caliper(cap.dist, 2), data = nuke.nopt)
</code></pre>

<p>matches on <code>cap</code>, insisting that paired units not differ by more than
2 pooled SDs in <code>cap</code>. If you would prefer to set a requirement on how
much paired units can differ in <code>cap</code> in its original units, rather
than standard units, then you would have to create <code>cap.dist</code> in a
somewhat different way.  There&#39;s an example on the help page for
<code>caliper()</code>. Enter <code>help(caliper)</code> at the <em>R</em> command line.</p>

<h2>Using <em>R</em> for matching and another program for matched analysis</h2>

<p>If you prefer to do your main work in another statistical package, you
can use <em>R</em> for matching and balance assessment, and then re-import
the matched data back into your preferred package for the main
analysis. A typical work flow might look something like this:</p>

<ol>
<li>Load data into your primary statistical package.</li>
<li>Preprocess data (handle missing values, combine variables into
single measures, etc).</li>
<li>Export data in a format <em>R</em> can read.</li>
<li>Load data into <em>R</em>.</li>
<li>Perform matching and balance testing.</li>
<li>Append matches to your data and export in a format your statistical
package can read.</li>
<li>Load appended data into your primary package and perform analyses.</li>
</ol>

<p>You already know how to perform the matching and balance testing, so
what remains are the import and export steps, along with appending
your matches to your original data.</p>

<p>When importing and exporting data, you must select a data format. In a
broad sense, you have two options: proprietary data formats (for
example <code>.dta</code> for Stata) or open standards (for example <code>.csv</code>, Comma
Separated Values). The advantage of proprietary formats is that they
may include additional information for <em>R</em> to use, such as the labels
on a categorical variable. The potential pitfall is that <em>R</em> might not
know how to read your particular file type. Open formats like CSV are
easy to read and write, but you may lose variable names, labels, or
other special forms of data. For reading and writing proprietary
formats, consider the use of the <code>foreign</code> library in <em>R</em>. See for
example <code>read.dta</code> and <code>write.dta</code>:</p>

<pre><code class="r">&gt; library(foreign)
&gt; ?read.dta
&gt; ?write.dta
</code></pre>

<p>For much more detail on this topic, see the <a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html">&ldquo;<em>R</em> Data Import/Export&rdquo;
manual</a>.</p>

<p>If you use CSV files, consult your statistical package&#39;s manuals for
details on how to export your data as a CSV. Once you have exported
your data into a file, open the file (using a text editor, not
Microsoft Word) to see if there is a header row of variable
names. Then, to import your data use the following:</p>

<pre><code class="r">&gt; my.plants &lt;- read.csv(&quot;nuclearplants.csv&quot;, header = TRUE)
</code></pre>

<p>If you do not have a header on your data change to <code>header = FALSE</code>.</p>

<p>At this point, you may proceed to conduct your matching as usual (for
example using an example from earlier in this document). When you are
done, you will need to append your match to your original data. The
safest way to do this is using the following code snippet:</p>

<pre><code class="r">&gt; plant.match &lt;- pairmatch(pr ~ cap, data = my.plants)
&gt; my.plants.extended &lt;- data.frame(my.plants, matches = plant.match, check.rows=TRUE)
</code></pre>

<p>Finally, export your data as a .csv file (or a proprietary format such
as with <code>write.dta</code> if that is what you are using):</p>

<pre><code class="r">&gt; write.csv(my.plants.extended, file = &quot;nuclearplants-with-matches.csv&quot;)
</code></pre>

<p>As one final note, many of the balance tests included in <code>RItools</code> are
available to Stata users directly from Stata. Information is available
at the <code>RItools</code> webpage at {<a href="http://www.jakebowers.org/RItools.html">http://www.jakebowers.org/RItools.html</a>}.</p>

<h2>Trying it out on your own</h2>

<p>For another interesting (toy) data set, do</p>

<pre><code class="r">&gt; data(tli, package=&quot;xtable&quot;)
&gt; head(tli)
##   grade sex disadvg ethnicty tlimth
## 1     6   M     YES HISPANIC     43
## 2     7   M      NO    BLACK     88
## 3     5   F     YES HISPANIC     34
## 4     3   M     YES HISPANIC     65
## 5     8   M     YES    WHITE     75
## 6     5   M      NO    BLACK     74
</code></pre>

<p>You might compare test scores for kids with <code>disadvg==&quot;YES&quot;` to
those of kids with</code>disadvg==&ldquo;NO&rdquo;&ldquo; using propensity matching, in
some combination with Mahalanobis matching and caliper matching.  A
check of propensity overlap may inform your decision as to whether to
include a propensity caliper.  Be sure to check for balance, and do
check the structure of the matched sets.</p>

<p>Three sources of \textit{real} data can be gotten as follows.  First,
Paul Rosenbaum has posted many of the data sets discussed in his <em>Design of
Observational Studies</em> (2010) to his web site.  If you have an active
internet connection then you can get them by (as of this writing):</p>

<pre><code class="r">&gt; download.file(&quot;http://www-stat.wharton.upenn.edu/~rosenbap/DOSdata.RData&quot;,
+               destfile=&quot;./DOSdata.RData&quot;)
&gt; load(&quot;./DOSdata.RData&quot;)
</code></pre>

<p>Second, the &rdquo;<code>lalonde</code>&ldquo; data set, discussed by Lalonde (1986,
<em>Am. Econom. Rev.</em>),
Dehejia and Wahba (1999, <em>JASA</em>) and Smith and Todd (2005,
<em>J. Econom.</em>), is bundled with several <em>R</em> packages, including
&rdquo;<code>{arm}</code>&ldquo; and &rdquo;<code>Matching</code>.&ldquo;  To get it:</p>

<pre><code class="r">&gt; install.packages(&quot;arm&quot;, dep=T) # if not already installed
&gt; data(lalonde, package=&quot;arm&quot;)
&gt; help(&quot;lalonde&quot;, package=&quot;arm&quot;)
</code></pre>

<p>Third, the data used by Connors et al (1996, <em>J. Am. Med. Assoc.</em>)
to examine costs, benefits and risks associated with right heart catheterization
is bundled with Frank Harrell and collaborators&#39; &rdquo;<code>Hmisc</code>&ldquo; package.</p>

<pre><code class="r">&gt; install.packages(&quot;Hmisc&quot;, dep=T) # if not already installed
&gt; Hmisc:::getHdata(rhc, what = &quot;all&quot;)
</code></pre>

</body>

</html>
